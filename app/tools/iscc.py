# -*- coding: utf-8 -*-
"""
ISCC Reference Implementation
"""
import re
import base64
from io import BytesIO
from hashlib import sha256
import unicodedata
from typing import List, ByteString, Sequence, BinaryIO, TypeVar, Generator

CHUNKING_GEAR = [
    9584138480181866666, 4739450037122062430, 1042006760432515769, 10675154520554330663, 15869016765101259526,
    8970928072383595559, 1399451202205921674, 14523822808097149755, 16268498464839721299, 10481172452375523505,
    17104617054662428007, 1589812074021361642, 5529368114994898429, 16097147859444922117, 7366391750793198740,
    11100538009918328137, 1389689728615383157, 4977138822009172500, 908349889557194910, 14452518814433479233,
    2122926032271239532, 591612022955043504, 9379034436570273189, 12748258297147873806, 4307386326245858243,
    13845229916084989633, 11224472648935237303, 7047696390035316099, 2021133566789993437, 17387162748083618158,
    11746787256992261957, 6644482612611712714, 15729398955930993486, 18187694890389888249, 13375007170405426180,
    4646676434852504131, 13152698236329639071, 899989819383117385, 1604228284900755822, 13429168974601667864,
    3706248770764044735, 3719799868214789934, 339511817415309475, 12306710798301877171, 9844020938499650522,
    13507342816267977422, 15331217600725578556, 7506003564454403634, 17943236144189306428, 282153689319390566,
    7654271695669749695, 2650412143911437370, 6193440044944269691, 9296646612477743744, 15077579129862372948,
    67630558006200567, 11937031764123301943, 1634327986517329169, 16073934395340319514, 11660580892053471307,
    12301495579660351243, 16908718276972184511, 6851717516129410187, 13288278789994352315, 17482170774163197685,
    12177168157992128323, 1679876621412537528, 15666827561093998679, 4235032027386979601, 17396011814487376094,
    2036017399572567727, 4977152437582070133, 11341111713611820820, 5866443846249079891, 5131277185090952872,
    8325299058005558320, 5701450024662049407, 15870252139465586153, 641910037851244477, 5172232175829573378,
    2261684586607900474, 11396825283718526131, 12408680075109652465, 7761877592432080901, 13820035802684848169,
    8150091535052795450, 1103357817677537274, 13470426615970288837, 4696524065622673976, 9336804607285957500,
    13043178028673218162, 7139020806469476608, 12450708403507569100, 2877039905016676547, 15118872351294838361,
    3277072151995360446, 1979210712452295885, 14822651643543876641, 5849754172112174627, 13664543478254756807,
    16186972696580520130, 14259131679517995788, 1772106294408535188, 2668205339646827112, 3734021086026184498,
    4257506854909152229, 6797729639474582495, 3708095106171770747, 15445894064208319783, 11045733249000282278,
    6925260395759991481, 6761677416581440942, 3134957115005596133, 5496794829211694837, 225035875953155227,
    18051382753002575119, 6911658830635795092, 6648838042848840266, 7680838377178993211, 14373546918520540763,
    7385952462173201391, 7500965322394952100, 15539214383494689771, 14355530880918970074, 4040759991734970063,
    1335151750647325670, 13713452291232361388, 8852782707920062625, 6076783566257059794, 14451547968886132839,
    6756882940270420653, 17423128808598833972, 5877907771709558759, 14308413074787508328, 12294727846616188882,
    13766545313722789196, 7000331838802888702, 15110028412924060381, 15869145452552081798, 10836437530623796047,
    1273143868608979117, 17728019699248776702, 379008101491021165, 6658832383485441856, 6005905363267598720,
    4792802520786808134, 17024928019214694263, 7949301678895773307, 14602122883430422290, 6416689239839102410,
    18112987618441438141, 5424513836620859057, 12327961344656070412, 18229731317766561349, 6214341855555485197,
    14659604854593022088, 18341976098904231516, 9093141550798891276, 4487469223051523007, 12576621890114680116,
    11368566035561888278, 16632902625329423294, 13764076000271015053, 11494903226088746337, 14079100963083335535,
    5976601008655555884, 5685807667042201553, 16503266544486236927, 5505089898459277917, 17076606531971661551,
    939769563919939433, 17217248958964594832, 11196454443995107214, 13253314556391295544, 17340262486782904124,
    5483165811177129540, 121736889831618943, 6318157315988658220, 14520375112718267902, 689388276875596813,
    5273319774965020902, 7975410517565653865, 13935269057627157047, 16821796908479891795, 5882048506860913277,
    18003709489856105216, 1424933842252756366, 6634557257081066175, 16179356916240399588, 11153419399622634817,
    15654294493035402949, 2652919763627807814, 16437183290373292867, 16903315446495122175, 3575318971059548300,
    3073697257555445515, 16187136733800880291, 15191964085364171996, 11982016174040399757, 1948589207658719032,
    14444449012119241408, 7130754012353479650, 7480280819583944745, 3603028513293740433, 7021162527209392860,
    2124450348946366496, 14349140477237426219, 7396225914272122063, 16288120608246645021, 7309794834881975478,
    16746864570463829614, 9239996606832866982, 14126189643057989505, 5785181374404079776, 16681042508550037223,
    9085478584447523753, 12879577862603639783, 13351556131001260565, 10860701565908202403, 9109516948909639475,
    2942389181877553466, 1907923359833671766, 1700327967934711796, 4355952370607563279, 6159416062364401684,
    8120694842642123744, 4670360822544180192, 12684384265447906291, 11518186189217338692, 14839496566538901930,
    13515715604989800698, 12135065096961528408, 9056982071865174221, 12690699907549395246, 2080896935929507230,
    14546126411900211421, 6222235617711806766, 13387691023848518640, 1259523422199249803, 1733690531272524911,
    16691543548458831721, 3252085970219428027, 790320086519395195, 8366099548552136926, 357423734596052102,
    6375583027298966643, 88639135753272123, 13813972796887520980, 8203570281250814300, 18377325011640278855,
    2922465295015278442, 2164203008979443347, 7447171935848155518, 3663261456454345351, 5865411828910435346,
    13570376904595974307
]

# Magic Constants

INPUT_TRIM = 128
B = TypeVar('B', BinaryIO, bytes)


def generate_meta_id(title: str, creators: str='', extra: str='', version: int=0) -> str:

    assert version == 0, "Only version 1 supported"

    title, creators, extra = trim(title, creators, extra)

    title = normalize_text(title)
    creators = normalize_creators(creators)
    extra = normalize_text(extra)

    concat = '\u0020'.join((title, creators, extra)).rstrip('\u007C')

    a = sliding_window(concat, width=2) * 3
    b = sliding_window(concat, width=3) * 2
    c = sliding_window(concat, width=4)
    n_grams = a + b + c

    hash_digests = [sha256(s.encode('utf-8')).digest() for s in n_grams]
    simhash_digest = similarity_hash(hash_digests)
    meta_id_digest = b'\x00' + simhash_digest[:7]

    return base64.b32encode(meta_id_digest).rstrip(b'=').decode('ascii')


def generate_instance_id(data: B) -> str:

    leaf_node_digests = [sha256d(b'\x00' + chunk) for chunk in data_chunks(data)]
    top_hash_digest = top_hash(leaf_node_digests)
    instance_id_digest = b'\x30' + top_hash_digest[:7]
    return base64.b32encode(instance_id_digest).rstrip(b'=').decode('ascii')


def top_hash(hashes: List[bytes]) -> bytes:

    size = len(hashes)
    if size == 1:
        return hashes[0]

    pairwise_hashed = []

    for i in range(0, len(hashes) - 1, 2):
        pairwise_hashed.append(hash_inner_nodes(hashes[i], hashes[i + 1]))

    if size % 2 == 1:
        pairwise_hashed.append(hash_inner_nodes(hashes[-1], hashes[-1]))

    return top_hash(pairwise_hashed)


def sha256d(data: bytes) -> bytes:
    return sha256(sha256(data).digest()).digest()


def hash_inner_nodes(a: bytes, b: bytes) -> bytes:
    return sha256d(b'\x01' + a + b)


def data_chunks(data: B) -> Generator[bytes, None, None]:

    if not hasattr(data, 'read'):
        data = BytesIO(data)

    section = data.read(640)
    counter = 0
    while True:
        if counter < 100:
            if len(section) < 640:
                section += data.read(640)
            if len(section) == 0:
                break
            boundary = chunk_length(section, 40, 20, 640, 0x016118, 0x00a0b1)
        else:
            if len(section) < 65536:
                section += data.read(65536)
            if len(section) == 0:
                break
            boundary = chunk_length(section, 4096, 2048, 65536, 0x0003590703530000, 0x0000d90003530000)

        yield section[:boundary]
        section = section[boundary:]
        counter += 1


def chunk_length(data: bytes, norm_size: int, min_size: int, max_size: int, mask_1: int, mask_2: int) -> int:
    data_length = len(data)
    i = min_size
    pattern = 0

    if data_length <= min_size:
        return data_length

    while i < min(norm_size, data_length):
        pattern = (pattern << 1) + CHUNKING_GEAR[data[i]]
        if not pattern & mask_1:
            return i
        i = i + 1
    while i < min(max_size, data_length):
        pattern = (pattern << 1) + CHUNKING_GEAR[data[i]]
        if not pattern & mask_2:
            return i
        i = i + 1
    return i


def normalize_text(text: str) -> str:

    whitelist = 'LNS'
    decomposed = unicodedata.normalize('NFD', text)
    chars = []

    for c in decomposed:
        cat = unicodedata.category(c)
        if cat.startswith('Z'):
            chars.append(' ')
        elif cat[0] in whitelist:
            chars.append(c.lower())

    filtered = ''.join(chars)
    collapsed = '\u0020'.join(filtered.split())
    normalized = unicodedata.normalize('NFC', collapsed)

    return normalized


def normalize_creators(text: str) -> str:

    nonum = re.sub("\d+", "", text, flags=re.UNICODE)

    creators = []

    for creator in nonum.split(';'):

        if ',' in creator:
            creator = ' '.join(reversed(creator.split(',')[:2]))
        ncreators = normalize_text(creator)

        tokens = ncreators.split()
        if not tokens:
            continue
        if tokens[0] == tokens[-1]:
            abridged = tokens[0]
        else:
            abridged = tokens[0][0] + tokens[-1]
        creators.append(abridged)

    return '\u0020'.join(sorted(creators))


def trim(*text: str) -> List[str]:

    trimmed = []
    for t in text:
        trimmed.append(unicodedata.normalize('NFKC', t)[:INPUT_TRIM])
    return trimmed


def sliding_window(text: str, width: int) -> List:

    assert width >= 2, "Sliding window width must be 2 or bigger."
    idx = range(max(len(text) - width + 1, 1))
    return [text[i:i + width] for i in idx]


def similarity_hash(hash_digests: Sequence[ByteString]) -> ByteString:

    n_bytes = len(hash_digests[0])
    n_bits = (n_bytes * 8)
    vector = [0] * n_bits

    for digest in hash_digests:

        assert len(digest) == n_bytes
        h = int.from_bytes(digest, 'big', signed=False)

        for i in range(n_bits):
            vector[i] += h & 1
            h >>= 1

    minfeatures = len(hash_digests) * 1. / 2
    shash = 0

    for i in range(n_bits):
        shash |= int(vector[i] >= minfeatures) << i

    return shash.to_bytes(n_bytes, 'big', signed=False)


def minimum_hash(hash_digests: Sequence[ByteString]) -> ByteString:
    # TODO Implement pure python minhash
    pass


def c2d(code: str) -> ByteString:

    return base64.b32decode(code + '===')


def c2i(code):

    digest = c2d(code)
    return int.from_bytes(digest[1:8], 'big', signed=False)


def hamming_distance(ident1: int, ident2: int) -> int:

    return bin(ident1 ^ ident2).count('1')